        -:    0:Source:D:/CLionProjects/lexAnalyzer/main.c
        -:    0:Graph:D:\CLionProjects\lexAnalyzer\cmake-build-debug-coverage\CMakeFiles\lexAnalyzer.dir\main.c.gcno
        -:    0:Data:D:\CLionProjects\lexAnalyzer\cmake-build-debug-coverage\CMakeFiles\lexAnalyzer.dir\main.c.gcda
        -:    0:Runs:1
        -:    0:Programs:1
        -:    1:#include <stdio.h>
        -:    2:#include <string.h>
        -:    3:#include <stdlib.h>
        -:    4:
        -:    5:#define LEN 1000
        -:    6:#define BUFFER_LEN 1024000
        -:    7:#define INPUT "input.txt"
        -:    8:
        -:    9:char instr[BUFFER_LEN];//输入符号串
        -:   10:int total_len;//输入符号串长度
        -:   11:int instr_index = 0;//当前输入符号读入字符的位置
        -:   12:char character[2];//全局变量字符，存放最新读入的字符
        -:   13:char token[LEN];//存放已读入的字符序列
        -:   14:char Reverse[LEN][10];//保留字表
        -:   15:char Boundary[LEN][10];//界符表
        -:   16:char Operator[LEN][10];//运算符表
        -:   17:int line = 1;//当前行数
        -:   18:int column = 1;//当前列数
        -:   19:int totalError = 0;//错误总数
        -:   20:
        -:   21:// 类别编码依次是 保留字、标识符、常数
        -:   22:enum sign_type {
        -:   23:    RESERVE = 1, SYMBOL = 2, CONSTANT = 3
        -:   24:};
        -:   25:
        -:   26:// 储存记号信息
        -:   27:typedef struct binary {
        -:   28:    int category;//类别编码
        -:   29:    int index;//表内位置
        -:   30:    char value[LEN];//记号内容
        -:   31:} Binary;
        -:   32:
        -:   33:Binary Symbol[LEN];//标识符集
        -:   34:Binary Digit[LEN];//常数集
        -:   35:int symbol_len = 0;//标识符集当前元素个数
        -:   36:int digit_len = 0;//常数集当前元素个数
        -:   37:
        -:   38:// 构造保留字表
        1:   39:void init_Reverse() {
        1:   40:    strcpy(Reverse[1], "auto");
        1:   41:    strcpy(Reverse[2], "break");
        1:   42:    strcpy(Reverse[3], "case");
        1:   43:    strcpy(Reverse[4], "char");
        1:   44:    strcpy(Reverse[5], "const");
        1:   45:    strcpy(Reverse[6], "continue");
        1:   46:    strcpy(Reverse[7], "default");
        1:   47:    strcpy(Reverse[8], "do");
        1:   48:    strcpy(Reverse[9], "double");
        1:   49:    strcpy(Reverse[10], "else");
        1:   50:    strcpy(Reverse[11], "enum");
        1:   51:    strcpy(Reverse[12], "extern");
        1:   52:    strcpy(Reverse[13], "float");
        1:   53:    strcpy(Reverse[14], "for");
        1:   54:    strcpy(Reverse[15], "goto");
        1:   55:    strcpy(Reverse[16], "if");
        1:   56:    strcpy(Reverse[17], "int");
        1:   57:    strcpy(Reverse[18], "long");
        1:   58:    strcpy(Reverse[19], "main");
        1:   59:    strcpy(Reverse[20], "register");
        1:   60:    strcpy(Reverse[21], "return");
        1:   61:    strcpy(Reverse[22], "short");
        1:   62:    strcpy(Reverse[23], "signed");
        1:   63:    strcpy(Reverse[24], "sizeof");
        1:   64:    strcpy(Reverse[25], "static");
        1:   65:    strcpy(Reverse[26], "struct");
        1:   66:    strcpy(Reverse[27], "switch");
        1:   67:    strcpy(Reverse[28], "typedef");
        1:   68:    strcpy(Reverse[29], "union");
        1:   69:    strcpy(Reverse[30], "unsigned");
        1:   70:    strcpy(Reverse[31], "void");
        1:   71:    strcpy(Reverse[32], "volatile");
        1:   72:    strcpy(Reverse[33], "while");
        1:   73:    strcpy(Reverse[34], "include");
        1:   74:    strcpy(Reverse[35], "define");
        1:   75:}
        -:   76:
        -:   77:// 构造界符表
        1:   78:void init_Boundary() {
        1:   79:    strcpy(Boundary[4], "(");
        1:   80:    strcpy(Boundary[5], ")");
        1:   81:    strcpy(Boundary[6], "[");
        1:   82:    strcpy(Boundary[7], "]");
        1:   83:    strcpy(Boundary[8], "{");
        1:   84:    strcpy(Boundary[9], "}");
        1:   85:    strcpy(Boundary[10], "/*");
        1:   86:    strcpy(Boundary[11], "*/");
        1:   87:    strcpy(Boundary[12], "\"");
        1:   88:    strcpy(Boundary[13], "\'");
        1:   89:    strcpy(Boundary[14], ",");
        1:   90:    strcpy(Boundary[15], ";");
        1:   91:    strcpy(Boundary[16], "#");
        1:   92:}
        -:   93:
        -:   94:// 构造运算符表
        1:   95:void init_Operator() {
        1:   96:    strcpy(Operator[17], "+");
        1:   97:    strcpy(Operator[18], "-");
        1:   98:    strcpy(Operator[19], "*");
        1:   99:    strcpy(Operator[20], "/");
        1:  100:    strcpy(Operator[21], "%");
        1:  101:    strcpy(Operator[22], "!");
        1:  102:    strcpy(Operator[23], "&&");
        1:  103:    strcpy(Operator[24], "||");
        1:  104:    strcpy(Operator[25], "++");
        1:  105:    strcpy(Operator[26], "--");
        1:  106:    strcpy(Operator[27], "&");
        1:  107:    strcpy(Operator[28], "|");
        1:  108:    strcpy(Operator[29], "^");
        1:  109:    strcpy(Operator[30], "~");
        1:  110:    strcpy(Operator[31], "<<");
        1:  111:    strcpy(Operator[32], ">>");
        1:  112:    strcpy(Operator[33], "<");
        1:  113:    strcpy(Operator[34], "<=");
        1:  114:    strcpy(Operator[35], ">");
        1:  115:    strcpy(Operator[36], ">=");
        1:  116:    strcpy(Operator[37], "!=");
        1:  117:    strcpy(Operator[38], "==");
        1:  118:    strcpy(Operator[39], "=");
        1:  119:    strcpy(Operator[40], "+=");
        1:  120:    strcpy(Operator[41], "-=");
        1:  121:    strcpy(Operator[42], "*=");
        1:  122:    strcpy(Operator[43], "/=");
        1:  123:    strcpy(Operator[44], "%=");
        1:  124:    strcpy(Operator[45], "<<=");
        1:  125:    strcpy(Operator[46], ">>=");
        1:  126:    strcpy(Operator[47], "&=");
        1:  127:    strcpy(Operator[48], "|=");
        1:  128:    strcpy(Operator[49], "^=");
        1:  129:    strcpy(Operator[50], ".");
        1:  130:    strcpy(Operator[51], "->");
        1:  131:    strcpy(Operator[52], "?");
        1:  132:    strcpy(Operator[53], ":");
        1:  133:}
        -:  134:
        -:  135:// 连接字符串 token 和 character
     8764:  136:void concat() {
     8764:  137:    strcat(token, character);
     8764:  138:}
        -:  139:
        -:  140:// 回退字符
     6063:  141:void retract() {
     6063:  142:    character[0] = ' ';
     6063:  143:    instr_index--;
     6063:  144:    column--;
     6063:  145:}
        -:  146:
        -:  147:// 判断是否为字母，是返回 1，否则返回 0
     7885:  148:int isLetter() {
     7885:  149:    if (character[0] >= 'A' && character[0] <= 'Z' || character[0] >= 'a' && character[0] <= 'z')
     7885:  149-block  0
     6785:  149-block  1
     7454:  149-block  2
     5873:  149-block  3
     6301:  150:        return 1;
     6301:  150-block  0
     1584:  151:    return 0;
     1584:  151-block  0
        -:  152:}
        -:  153:
        -:  154:// 判断是否为数字，是返回 1，否则返回 0
     2390:  155:int isDigit() {
     2390:  156:    if (character[0] >= '0' && character[0] <= '9')
     2390:  156-block  0
     1274:  156-block  1
      464:  157:        return 1;
      464:  157-block  0
     1926:  158:    return 0;
     1926:  158-block  0
        -:  159:}
        -:  160:
        -:  161:// 读入一个字符
    28239:  162:void getChar() {
    28239:  163:    character[0] = instr[instr_index++];
    28239:  164:    column++;
    28239:  165:}
        -:  166:
        -:  167:// 检查 character 中的字符是否为空白字符，若是，则调用 getchar 读入下一个字符，直到 character 中的字符是非空白字符为止
     4366:  168:void getNBC() {
     4366:  169:    int flag = 0;
    18077:  170:    while (character[0] == ' ' || character[0] == '\n' || character[0] == '\t') {
     4366:  170-block  0
    18077:  170-block  1
     5142:  170-block  2
     4366:  170-block  3
    13711:  171:        if (character[0] == '\n') {
    13711:  171-block  0
      776:  172:            line++;
      776:  173:            column = 1;
      776:  173-block  0
        -:  174:        }
    13711:  175:        getChar();
    13711:  175-block  0
    13711:  176:        flag = 1;
        -:  177:    }
     4366:  178:    if (flag == 1)
     4366:  178-block  0
     4366:  179:        retract();
     4366:  179-block  0
     4366:  180:}
        -:  181:
        -:  182:// 匹配保留字符，并返回下标
     1520:  183:int reverse() {
  1182343:  184:    for (int i = 0; i < LEN; i++) {
     1520:  184-block  0
  1180823:  184-block  1
  1182343:  184-block  2
  1181167:  185:        if (strcmp(Reverse[i], token) == 0)
  1181167:  185-block  0
      344:  186:            return i;
      344:  186-block  0
        -:  187:    }
     1176:  188:    return -1;
     1176:  188-block  0
        -:  189:}
        -:  190:
        -:  191:// 处理标识符：对 token 中的字符串查标识符表，若查到，返回它在表中的位置下标，否则，把 token 添加到表尾并返回下标
     1176:  192:int symbol() {
   119744:  193:    for (int i = 0; i < symbol_len; i++) {
     1176:  193-block  0
   118568:  193-block  1
   119744:  193-block  2
   119475:  194:        if (strcmp(token, Symbol[i].value) == 0)
   119475:  194-block  0
      907:  195:            return i;
      907:  195-block  0
        -:  196:    }
      269:  197:    strcpy(Symbol[symbol_len].value, token);
      269:  198:    Symbol[symbol_len].category = SYMBOL;
      269:  199:    Symbol[symbol_len].index = symbol_len;
      269:  200:    symbol_len++;
      269:  201:    return symbol_len - 1;
      269:  201-block  0
        -:  202:}
        -:  203:
        -:  204:// 处理常数：对 token 中的字符串查常数表，若查到，返回它在表中的位置下标，否则，把 token 添加到表尾并返回下标
      342:  205:int constant() {
     4588:  206:    for (int i = 0; i < digit_len; i++) {
      342:  206-block  0
     4246:  206-block  1
     4588:  206-block  2
     4532:  207:        if (strcmp(token, Digit[i].value) == 0)
     4532:  207-block  0
      286:  208:            return i;
      286:  208-block  0
        -:  209:    }
       56:  210:    strcpy(Digit[digit_len].value, token);
       56:  211:    Digit[digit_len].category = CONSTANT;
       56:  212:    Digit[digit_len].index = digit_len;
       56:  213:    digit_len++;
       56:  214:    return digit_len - 1;
       56:  214-block  0
        -:  215:}
        -:  216:
        -:  217:// 打印错误位置信息
    #####:  218:Binary error() {
    #####:  219:    Binary error = {0, 0, "-"};
    #####:  220:    totalError++;
    #####:  221:    printf("An error was found in Line %d, Column %d\n", line, column);
    %%%%%:  221-block  0
    #####:  222:    return error;
        -:  223:}
        -:  224:
        -:  225:// 词法分析函数，逐个识别单词
     4366:  226:Binary LexAnalyze() {
     4366:  227:    memset(token, 0, LEN);
     4366:  228:    character[0] = ' ';
     4366:  229:    getNBC();
     4366:  229-block  0
     4366:  230:    getChar();
     4366:  231:    int flag = 0;
     4366:  232:    int table_index = 0;
     4366:  233:    int num = 0;
     4366:  234:    switch (character[0]) {
     1186:  235:        case 'a':
        -:  236:        case 'b':
        -:  237:        case 'c':
        -:  238:        case 'd':
        -:  239:        case 'e':
        -:  240:        case 'f':
        -:  241:        case 'g':
        -:  242:        case 'h':
        -:  243:        case 'i':
        -:  244:        case 'j':
        -:  245:        case 'k':
        -:  246:        case 'l':
        -:  247:        case 'm':
        -:  248:        case 'n':
        -:  249:        case 'o':
        -:  250:        case 'p':
        -:  251:        case 'q':
        -:  252:        case 'r':
        -:  253:        case 's':
        -:  254:        case 't':
        -:  255:        case 'u':
        -:  256:        case 'v':
        -:  257:        case 'w':
        -:  258:        case 'x':
        -:  259:        case 'y':
        -:  260:        case 'z':
        -:  261:        case 'A':
        -:  262:        case 'B':
        -:  263:        case 'C':
        -:  264:        case 'D':
        -:  265:        case 'E':
        -:  266:        case 'F':
        -:  267:        case 'G':
        -:  268:        case 'H':
        -:  269:        case 'I':
        -:  270:        case 'J':
        -:  271:        case 'K':
        -:  272:        case 'L':
        -:  273:        case 'M':
        -:  274:        case 'N':
        -:  275:        case 'O':
        -:  276:        case 'P':
        -:  277:        case 'Q':
        -:  278:        case 'R':
        -:  279:        case 'S':
        -:  280:        case 'T':
        -:  281:        case 'U':
        -:  282:        case 'V':
        -:  283:        case 'W':
        -:  284:        case 'X':
        -:  285:        case 'Y':
        -:  286:        case 'Z':
        -:  287:        case '_':
     7543:  288:            while (isLetter() == 1 || isDigit() == 1 || character[0] == '_') {
     1186:  288-block  0
     7543:  288-block  1
     1242:  288-block  2
     1242:  288-block  3
     6357:  289:                concat();
     6357:  289-block  0
     6357:  290:                getChar();
        -:  291:            }
     1186:  292:            retract();
     1186:  292-block  0
     1186:  293:            num = reverse();
     1186:  294:            if (num != -1) {
      344:  295:                Binary res = {RESERVE, num};
      344:  296:                strcpy(res.value, token);
      344:  297:                return res;
      344:  297-block  0
        -:  298:            }
        -:  299:            else {
      842:  300:                table_index = symbol();
      842:  300-block  0
      842:  301:                return Symbol[table_index];
        -:  302:            }
      342:  303:        case '0':
        -:  304:        case '1':
        -:  305:        case '2':
        -:  306:        case '3':
        -:  307:        case '4':
        -:  308:        case '5':
        -:  309:        case '6':
        -:  310:        case '7':
        -:  311:        case '8':
        -:  312:        case '9':
     806*:  313:            while (isDigit() == 1 || (character[0] == '.' && !flag)) {
      342:  313-block  0
      806:  313-block  1
      342:  313-block  2
    %%%%%:  313-block  3
      464:  314:                if (character[0] == '.')
      464:  314-block  0
    #####:  315:                    flag = 1;
    %%%%%:  315-block  0
      464:  316:                concat();
      464:  316-block  0
      464:  317:                getChar();
        -:  318:            }
        -:  319:            // 若是科学计数法
      342:  320:            if (character[0] == 'E' || character[0] == 'e') {
      342:  320-block  0
      342:  320-block  1
    #####:  321:                concat();
    %%%%%:  321-block  0
    #####:  322:                getChar();
    #####:  323:                flag = 0;
    #####:  324:                if (character[0] == '+' || character[0] == '-') {
    %%%%%:  324-block  0
    #####:  325:                    concat();
    %%%%%:  325-block  0
    #####:  326:                    getChar();
        -:  327:                }
    #####:  328:                while (isDigit() == 1 || (character[0] == '.' && !flag)) {
    %%%%%:  328-block  0
    %%%%%:  328-block  1
    %%%%%:  328-block  2
    %%%%%:  328-block  3
    #####:  329:                    if (character[0] == '.')
    %%%%%:  329-block  0
    #####:  330:                        flag = 1;
    %%%%%:  330-block  0
    #####:  331:                    concat();
    %%%%%:  331-block  0
    #####:  332:                    getChar();
        -:  333:                }
        -:  334:            }
      342:  335:            int legal_flag = 0;
        -:  336:            // 若是非法标识符或非法数字，报错
      342:  337:            while (isLetter() == 1 || isDigit() == 1 || character[0] == '_' || character[0] == '.') {
      342:  337-block  0
      342:  337-block  1
      342:  337-block  2
      342:  337-block  3
      342:  337-block  4
    #####:  338:                concat();
    %%%%%:  338-block  0
    #####:  339:                getChar();
    #####:  340:                legal_flag = 1;
        -:  341:            }
      342:  342:            retract();
      342:  342-block  0
      342:  343:            if (legal_flag == 1)
    #####:  344:                return error();
    %%%%%:  344-block  0
      342:  345:            table_index = constant();
      342:  345-block  0
      342:  346:            return Digit[table_index];
       18:  347:        case '<':
       18:  348:            getChar();
       18:  348-block  0
       18:  349:            if (character[0] == '=') {
        5:  350:                Binary res = {34, 0, "<="};
        5:  351:                return res;
        5:  351-block  0
        -:  352:            }
       13:  353:            else if (character[0] == '<') {
       13:  353-block  0
    #####:  354:                getChar();
    %%%%%:  354-block  0
    #####:  355:                if (character[0] == '=') {
    #####:  356:                    Binary res = {45, 0, "<<="};
    #####:  357:                    return res;
    %%%%%:  357-block  0
        -:  358:                }
        -:  359:                else {
    #####:  360:                    retract();
    %%%%%:  360-block  0
    #####:  361:                    Binary res = {31, 0, "<<"};
    #####:  362:                    return res;
        -:  363:                }
        -:  364:            }
        -:  365:            else {
       13:  366:                retract();
       13:  366-block  0
       13:  367:                Binary res = {33, 0, "<"};
       13:  368:                return res;
        -:  369:            }
        9:  370:        case '>':
        9:  371:            getChar();
        9:  371-block  0
        9:  372:            if (character[0] == '=') {
        6:  373:                Binary res = {36, 0, ">="};
        6:  374:                return res;
        6:  374-block  0
        -:  375:            }
        3:  376:            else if (character[0] == '>') {
        3:  376-block  0
    #####:  377:                getChar();
    %%%%%:  377-block  0
    #####:  378:                if (character[0] == '=') {
    #####:  379:                    Binary res = {46, 0, ">>="};
    #####:  380:                    return res;
    %%%%%:  380-block  0
        -:  381:                }
        -:  382:                else {
    #####:  383:                    retract();
    %%%%%:  383-block  0
    #####:  384:                    Binary res = {32, 0, ">>"};
    #####:  385:                    return res;
        -:  386:                }
        -:  387:            }
        -:  388:            else {
        3:  389:                retract();
        3:  389-block  0
        3:  390:                Binary res = {35, 0, ">"};
        3:  391:                return res;
        -:  392:            }
      183:  393:        case '=':
      183:  394:            getChar();
      183:  394-block  0
      183:  395:            if (character[0] == '=') {
       78:  396:                Binary res = {38, 0, "=="};
       78:  397:                return res;
       78:  397-block  0
        -:  398:            }
        -:  399:            else {
      105:  400:                retract();
      105:  400-block  0
      105:  401:                Binary res = {39, 0, "="};
      105:  402:                return res;
        -:  403:            }
       13:  404:        case '!':
       13:  405:            getChar();
       13:  405-block  0
       13:  406:            if (character[0] == '=') {
       11:  407:                Binary res = {37, 0, "!="};
       11:  408:                return res;
       11:  408-block  0
        -:  409:            }
        -:  410:            else {
        2:  411:                retract();
        2:  411-block  0
        2:  412:                Binary res = {22, 0, "!"};
        2:  413:                return res;
        -:  414:            }
       16:  415:        case '+':
       16:  416:            getChar();
       16:  416-block  0
       16:  417:            if (character[0] == '=') {
    #####:  418:                Binary res = {40, 0, "+="};
    #####:  419:                return res;
    %%%%%:  419-block  0
        -:  420:            }
       16:  421:            else if (character[0] == '+') {
       16:  421-block  0
       16:  422:                Binary res = {25, 0, "++"};
       16:  423:                return res;
       16:  423-block  0
        -:  424:            }
        -:  425:            else {
    #####:  426:                retract();
    %%%%%:  426-block  0
    #####:  427:                Binary res = {17, 0, "+"};
    #####:  428:                return res;
        -:  429:            }
        8:  430:        case '-':
        8:  431:            getChar();
        8:  431-block  0
        8:  432:            if (character[0] == '=') {
    #####:  433:                Binary res = {41, 0, "-="};
    #####:  434:                return res;
    %%%%%:  434-block  0
        -:  435:            }
        8:  436:            else if (character[0] == '-') {
        8:  436-block  0
        2:  437:                Binary res = {26, 0, "--"};
        2:  438:                return res;
        2:  438-block  0
        -:  439:            }
        6:  440:            else if (character[0] == '>') {
        6:  440-block  0
    #####:  441:                Binary res = {51, 0, "->"};
    #####:  442:                return res;
    %%%%%:  442-block  0
        -:  443:            }
        -:  444:            else {
        6:  445:                retract();
        6:  445-block  0
        6:  446:                Binary res = {18, 0, "-"};
        6:  447:                return res;
        -:  448:            }
        1:  449:        case '*':
        1:  450:            getChar();
        1:  450-block  0
        1:  451:            if (character[0] == '=') {
    #####:  452:                Binary res = {42, 0, "*="};
    #####:  453:                return res;
    %%%%%:  453-block  0
        -:  454:            }
        -:  455:            else {
        1:  456:                retract();
        1:  456-block  0
        1:  457:                Binary res = {19, 0, "*"};
        1:  458:                return res;
        -:  459:            }
       39:  460:        case '/':
       39:  461:            getChar();
       39:  461-block  0
       39:  462:            if (character[0] == '=') {
    #####:  463:                Binary res = {43, 0, "/="};
    #####:  464:                return res;
    %%%%%:  464-block  0
        -:  465:            }
        -:  466:                // 跳过 "//" 注释
       39:  467:            else if (character[0] == '/') {
       39:  467-block  0
     1461:  468:                while (character[0] != '\n') {
       39:  468-block  0
     1461:  468-block  1
     1422:  469:                    getChar();
     1422:  469-block  0
        -:  470:                }
       39:  471:                retract();
       39:  471-block  0
       39:  472:                Binary res = {0, 0, "-"};
       39:  473:                return res;
        -:  474:            }
        -:  475:                // 跳过 "/**/" 注释
    #####:  476:            else if (character[0] == '*') {
    %%%%%:  476-block  0
    #####:  477:                while (instr_index <= total_len) {
    %%%%%:  477-block  0
    %%%%%:  477-block  1
    #####:  478:                    getChar();
    %%%%%:  478-block  0
    #####:  479:                    if (character[0] == '*') {
    #####:  480:                        getChar();
    %%%%%:  480-block  0
    #####:  481:                        if (character[0] == '/')
    #####:  482:                            break;
    %%%%%:  482-block  0
        -:  483:                        else
    #####:  484:                            retract();
    %%%%%:  484-block  0
        -:  485:                    }
    #####:  486:                    else if (character[0] == '\n') {
    %%%%%:  486-block  0
    #####:  487:                        line++;
    #####:  488:                        column = 1;
    %%%%%:  488-block  0
        -:  489:                    }
        -:  490:                }
    #####:  491:                if (character[0] == '\0')
    %%%%%:  491-block  0
    #####:  492:                    return error();
    %%%%%:  492-block  0
    #####:  493:                Binary res = {0, 0, "-"};
    #####:  494:                return res;
    %%%%%:  494-block  0
        -:  495:            }
        -:  496:            else {
    #####:  497:                retract();
    %%%%%:  497-block  0
    #####:  498:                Binary res = {20, 0, "/"};
    #####:  499:                return res;
        -:  500:            }
        -:  501:
    #####:  502:        case '%':
    #####:  503:            getChar();
    %%%%%:  503-block  0
    #####:  504:            if (character[0] == '=') {
    #####:  505:                Binary res = {44, 0, "%="};
    #####:  506:                return res;
    %%%%%:  506-block  0
        -:  507:            }
        -:  508:            else {
    #####:  509:                retract();
    %%%%%:  509-block  0
    #####:  510:                Binary res = {21, 0, "%"};
    #####:  511:                return res;
        -:  512:            }
        7:  513:        case '&':
        7:  514:            getChar();
        7:  514-block  0
        7:  515:            if (character[0] == '=') {
    #####:  516:                Binary res = {47, 0, "&="};
    #####:  517:                return res;
    %%%%%:  517-block  0
        -:  518:            }
        7:  519:            else if (character[0] == '&') {
        7:  519-block  0
        7:  520:                Binary res = {23, 0, "&&"};
        7:  521:                return res;
        7:  521-block  0
        -:  522:            }
        -:  523:            else {
    #####:  524:                retract();
    %%%%%:  524-block  0
    #####:  525:                Binary res = {27, 0, "&"};
    #####:  526:                return res;
        -:  527:            }
       16:  528:        case '|':
       16:  529:            getChar();
       16:  529-block  0
       16:  530:            if (character[0] == '=') {
    #####:  531:                Binary res = {48, 0, "|="};
    #####:  532:                return res;
    %%%%%:  532-block  0
        -:  533:            }
       16:  534:            else if (character[0] == '|') {
       16:  534-block  0
       16:  535:                Binary res = {24, 0, "||"};
       16:  536:                return res;
       16:  536-block  0
        -:  537:            }
        -:  538:            else {
    #####:  539:                retract();
    %%%%%:  539-block  0
    #####:  540:                Binary res = {28, 0, "|"};
    #####:  541:                return res;
        -:  542:            }
    #####:  543:        case '^':
    #####:  544:            getChar();
    %%%%%:  544-block  0
    #####:  545:            if (character[0] == '=') {
    #####:  546:                Binary res = {49, 0, "^="};
    #####:  547:                return res;
    %%%%%:  547-block  0
        -:  548:            }
        -:  549:            else {
    #####:  550:                retract();
    %%%%%:  550-block  0
    #####:  551:                Binary res = {29, 0, "^"};
    #####:  552:                return res;
        -:  553:            }
    #####:  554:        case '~':
    #####:  555:            if (character[0] == '~') {
    %%%%%:  555-block  0
    #####:  556:                Binary res = {30, 0, "~"};
    #####:  557:                return res;
    %%%%%:  557-block  0
        -:  558:            }
        -:  559:        case '.':
       27:  560:            if (character[0] == '.') {
       27:  560-block  0
       27:  561:                Binary res = {50, 0, "."};
       27:  562:                return res;
       27:  562-block  0
        -:  563:            }
        -:  564:        case '?':
    #####:  565:            if (character[0] == '?') {
    %%%%%:  565-block  0
    #####:  566:                Binary res = {52, 0, "?"};
    #####:  567:                return res;
    %%%%%:  567-block  0
        -:  568:            }
        -:  569:        case ':':
       92:  570:            if (character[0] == ':') {
       92:  570-block  0
       92:  571:                Binary res = {53, 0, ":"};
       92:  572:                return res;
       92:  572-block  0
        -:  573:            }
        -:  574:        case '(':
      333:  575:            if (character[0] == '(') {
      333:  575-block  0
      333:  576:                Binary res = {4, 0, "("};
      333:  577:                return res;
      333:  577-block  0
        -:  578:            }
        -:  579:        case ')':
      333:  580:            if (character[0] == ')') {
      333:  580-block  0
      333:  581:                Binary res = {5, 0, ")"};
      333:  582:                return res;
      333:  582-block  0
        -:  583:            }
        -:  584:        case '[':
      216:  585:            if (character[0] == '[') {
      216:  585-block  0
      216:  586:                Binary res = {6, 0, "["};
      216:  587:                return res;
      216:  587-block  0
        -:  588:            }
        -:  589:        case ']':
      216:  590:            if (character[0] == ']') {
      216:  590-block  0
      216:  591:                Binary res = {7, 0, "]"};
      216:  592:                return res;
      216:  592-block  0
        -:  593:            }
        -:  594:        case '{':
      166:  595:            if (character[0] == '{') {
      166:  595-block  0
      166:  596:                Binary res = {8, 0, "{"};
      166:  597:                return res;
      166:  597-block  0
        -:  598:            }
        -:  599:        case '}':
      166:  600:            if (character[0] == '}') {
      166:  600-block  0
      166:  601:                Binary res = {9, 0, "}"};
      166:  602:                return res;
      166:  602-block  0
        -:  603:            }
        -:  604:        case ',':
      236:  605:            if (character[0] == ',') {
      236:  605-block  0
      236:  606:                Binary res = {14, 0, ","};
      236:  607:                return res;
      236:  607-block  0
        -:  608:            }
        -:  609:        case ';':
      402:  610:            if (character[0] == ';') {
      402:  610-block  0
      402:  611:                Binary res = {15, 0, ";"};
      402:  612:                return res;
      402:  612-block  0
        -:  613:            }
        -:  614:        case '#':
        6:  615:            if (character[0] == '#') {
        6:  615-block  0
        6:  616:                Binary res = {16, 0, "#"};
        6:  617:                return res;
        6:  617-block  0
        -:  618:            }
        -:  619:        case '\"':
      162:  620:            concat();
      162:  620-block  0
      162:  621:            getChar();
     1238:  622:            while (character[0] != '\"' && instr_index <= total_len) {
     1238:  622-block  0
     1076:  622-block  1
     1076:  623:                if (character[0] == '\\') {
     1076:  623-block  0
       71:  624:                    concat();
       71:  624-block  0
       71:  625:                    getChar();
       71:  626:                    if (character[0] == '\"' || character[0] == '\'' || character[0] == '\\') {
       70:  626-block  0
       69:  626-block  1
        2:  627:                        concat();
        2:  627-block  0
        2:  628:                        getChar();
        -:  629:                    }
        -:  630:                }
     1005:  631:                else if (character[0] == '\n') {
     1005:  631-block  0
    #####:  632:                    line++;
    #####:  633:                    column = 1;
    %%%%%:  633-block  0
        -:  634:                }
        -:  635:                else {
     1005:  636:                    concat();
     1005:  636-block  0
     1005:  637:                    getChar();
        -:  638:                }
        -:  639:            }
      162:  640:            if (character[0] == '\0') {
      162:  640-block  0
    #####:  641:                return error();
    %%%%%:  641-block  0
        -:  642:            }
      162:  643:            concat();
      162:  643-block  0
      162:  644:            num = reverse();
      162:  645:            if (num != -1) {
    #####:  646:                Binary res = {RESERVE, num};
    #####:  647:                strcpy(res.value, token);
    #####:  648:                return res;
    %%%%%:  648-block  0
        -:  649:            }
        -:  650:            else {
      162:  651:                table_index = symbol();
      162:  651-block  0
      162:  652:                return Symbol[table_index];
        -:  653:            }
      172:  654:        case '\'':
      172:  655:            concat();
      172:  655-block  0
      172:  656:            getChar();
      357:  657:            while (character[0] != '\'' && instr_index < total_len) {
      357:  657-block  0
      185:  657-block  1
      185:  658:                if (character[0] == '\\') {
      185:  658-block  0
       25:  659:                    concat();
       25:  659-block  0
       25:  660:                    getChar();
       25:  661:                    if (character[0] == '\'' || character[0] == '\"' || character[0] == '\\') {
       21:  661-block  0
       17:  661-block  1
       12:  662:                        concat();
       12:  662-block  0
       12:  663:                        getChar();
        -:  664:                    }
        -:  665:                }
        -:  666:                else {
      160:  667:                    concat();
      160:  667-block  0
      160:  668:                    getChar();
        -:  669:                }
        -:  670:            }
      172:  671:            if (character[0] == '\n') {
      172:  671-block  0
    #####:  672:                line++;
    #####:  673:                column = 1;
    #####:  674:                return error();
    %%%%%:  674-block  0
        -:  675:            }
      172:  676:            concat();
      172:  676-block  0
      172:  677:            num = reverse();
      172:  678:            if (num != -1) {
    #####:  679:                Binary res = {RESERVE, num};
    #####:  680:                strcpy(res.value, token);
    #####:  681:                return res;
    %%%%%:  681-block  0
        -:  682:            }
        -:  683:            else {
      172:  684:                table_index = symbol();
      172:  684-block  0
      172:  685:                return Symbol[table_index];
        -:  686:            }
        1:  687:        case '\0':
        1:  687-block  0
        -:  688:            if (1) {
        1:  689:                Binary res = {0, 0, "EOF"};
        1:  690:                return res;
        1:  690-block  0
        -:  691:            }
        -:  692:        default:
    #####:  693:            return error();
    %%%%%:  693-block  0
        -:  694:    }
        -:  695:}
        -:  696:
        -:  697:// 打印所有词汇表
        1:  698:void show_table() {
        1:  699:    printf("\n==================Reserve==================\n");
        1:  699-block  0
        1:  700:    printf("Reverse\t\tCategory\tIndex\n");
     1001:  701:    for (int i = 0; i < LEN; i++) {
     1000:  701-block  0
     1001:  701-block  1
     1000:  702:        if (Reverse[i][0] != '\0') {
     1000:  702-block  0
       35:  703:            if (strlen(Reverse[i]) >= 8)
       35:  703-block  0
        4:  704:                printf("%s\t%d\t\t%d\n", Reverse[i], RESERVE, i);
        4:  704-block  0
        -:  705:            else
       31:  706:                printf("%s\t\t%d\t\t%d\n", Reverse[i], RESERVE, i);
       31:  706-block  0
        -:  707:        }
        -:  708:    }
        1:  709:    printf("\n==================Boundary==================\n");
        1:  709-block  0
        1:  710:    printf("Boundary\tCategory\n");
     1001:  711:    for (int i = 0; i < LEN; i++) {
     1000:  711-block  0
     1001:  711-block  1
     1000:  712:        if (Boundary[i][0] != '\0')
     1000:  712-block  0
       13:  713:            printf("%s\t\t%d\n", Boundary[i], i);
       13:  713-block  0
        -:  714:    }
        1:  715:    printf("\n==================Operator==================\n");
        1:  715-block  0
        1:  716:    printf("Operator\tCategory\n");
     1001:  717:    for (int i = 0; i < LEN; i++) {
     1000:  717-block  0
     1001:  717-block  1
     1000:  718:        if (Operator[i][0] != '\0')
     1000:  718-block  0
       37:  719:            printf("%s\t\t%d\n", Operator[i], i);
       37:  719-block  0
        -:  720:    }
        1:  721:    printf("\n==================Symbol==================\n");
        1:  721-block  0
        1:  722:    printf("Symbol\t\tCategory\tIndex\n");
      270:  723:    for (int i = 0; i < symbol_len; i++) {
      269:  723-block  0
      270:  723-block  1
      269:  724:        if (strlen(Symbol[i].value) >= 8)
      269:  724-block  0
       56:  725:            printf("%s\t%d\t\t%d\n", Symbol[i].value, SYMBOL, Symbol[i].index);
       56:  725-block  0
        -:  726:        else
      213:  727:            printf("%s\t\t%d\t\t%d\n", Symbol[i].value, SYMBOL, Symbol[i].index);
      213:  727-block  0
        -:  728:    }
        1:  729:    printf("\n==================Constant==================\n");
        1:  729-block  0
        1:  730:    printf("Constant\tCategory\tIndex\n");
       57:  731:    for (int i = 0; i < digit_len; i++) {
       56:  731-block  0
       57:  731-block  1
       56:  732:        if (strlen(Digit[i].value) >= 8)
       56:  732-block  0
    #####:  733:            printf("%s\t%d\t\t%d\n", Digit[i].value, CONSTANT, Digit[i].index);
    %%%%%:  733-block  0
        -:  734:        else
       56:  735:            printf("%s\t\t%d\t\t%d\n", Digit[i].value, CONSTANT, Digit[i].index);
       56:  735-block  0
        -:  736:    }
        1:  737:}
        -:  738:
        1:  739:int main() {
        1:  740:    init_Reverse();
        1:  740-block  0
        1:  741:    init_Boundary();
        1:  742:    init_Operator();
        1:  743:    instr_index = 0;
        1:  744:    character[0] = ' ';
        1:  745:    memset(token, 0, LEN);
        1:  746:    memset(instr, 0, BUFFER_LEN);
        -:  747:
        -:  748:    // 把文本文件读入到字符数组缓冲区中
        -:  749:    FILE *fp;
        1:  750:    if ((fp = fopen(INPUT, "r")) == NULL) {
    #####:  751:        printf("Fail to open %s !\n", INPUT);
    %%%%%:  751-block  0
    #####:  752:        exit(1);
        -:  753:    }
        -:  754:    char ch[2];
        1:  755:    ch[0] = fgetc(fp);
        1:  755-block  0
    22176:  756:    while (ch[0] != EOF) {
    22176:  756-block  0
    22175:  757:        strcat(instr, ch);
    22175:  758:        ch[0] = fgetc(fp);
    22175:  758-block  0
        -:  759:    }
        1:  760:    total_len = strlen(instr);
        1:  761:    fclose(fp);
        1:  761-block  0
        -:  762:
        1:  763:    Binary word = {0, 0, "-"};
        1:  764:    printf("\nTips : Category of Reserve is 1, Symbol is 2, Constant is 3\n");
        1:  765:    printf("\n------------------------Results------------------------\n");
     4367:  766:    while (instr_index < total_len) {
     4367:  766-block  0
     4366:  767:        word = LexAnalyze();
     4366:  767-block  0
     4366:  768:        if (word.category != 0) {
     4326:  769:            printf("word\t\t(%d, %s)\n", word.category, word.value);
     4326:  769-block  0
        -:  770:        }
        -:  771:    }
        1:  772:    if (totalError >= 2) {
        1:  772-block  0
    #####:  773:        printf("%d errors were found!\n", totalError);
    %%%%%:  773-block  0
        -:  774:    }
        -:  775:    else {
        1:  776:        printf("%d error was found!\n", totalError);
        1:  776-block  0
        -:  777:    }
        -:  778:
        1:  779:    printf("\n------------------------Vocabulary------------------------\n");
        1:  779-block  0
        1:  780:    show_table();
        -:  781:
        -:  782://    system("pause");
        1:  783:    return 0;
        -:  784:}
